package ngordnet;
import com.xeiam.xchart.QuickChart;
import com.xeiam.xchart.Chart;
import com.xeiam.xchart.SwingWrapper;
import com.xeiam.xchart.ChartBuilder;
import javax.swing.JFrame;
import java.util.Collection;
import java.util.Set;
import java.util.LinkedList;

/** This class uses the xChart library to display the results obtained from ngordnet.
 *  It was adapted from code written by Josh Hug at UC Berkeley.
 *  Unchecked operations warnings generated by the java compiler have been suppressed for this class.
 *  They are caused by the use of generic collections to store data.  I hope to find a more elegant
 *  fix for this at some point. */

@SuppressWarnings("unchecked")
public class Plotter {
    
    /** The default width of charts drawn by xChart. */
    private static final int WIDTH = 800;

    /** The default height of charts drawn by xChart. */
    private static final int HEIGHT = 600;
    
    /** Makes a plot showing overlaid individual normalized count for every word in WORDS from STARTYEAR
     *  to ENDYEAR using NGM as a data source. */
    public static void plotAllWords(NGramMap ngm, String[] words, 
                                    int startYear, int endYear) {
        Chart chart = new ChartBuilder().width(WIDTH).height(HEIGHT)
            .xAxisTitle("years").yAxisTitle("data").build();
        int seriesAdded = 0;
        for (String word : words) {
            TimeSeries bundle = ngm.weightHistory(word, startYear, endYear);
            if (bundle.size() == 0) {
                System.out.println("No data for " + word);
                continue;
            }
            chart.addSeries(word, bundle.years(), bundle.data());
            seriesAdded = seriesAdded + 1;
        }   
        if (seriesAdded != 0) {
            JFrame frame = new SwingWrapper(chart).displayChart();
            frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
        }
    }

    /** Creates overlaid category weight plots for each category label in CATEGORYLABELS
     *  from STARTYEAR to ENDYEAR using NGM and WN as data sources. */
    public static void plotCategoryWeights(NGramMap ngm, WordNet wn,
                       String[] categoryLabels, int startYear, int endYear) {
        Chart chart = new ChartBuilder().width(WIDTH).height(HEIGHT)
            .xAxisTitle("years").yAxisTitle("data").build();
        int seriesAdded = 0;
        for (String categoryLabel : categoryLabels) {
            Set<String> words = wn.hyponyms(categoryLabel);
            TimeSeries<Double> bundle = ngm.summedWeightHistory(words, startYear, endYear);
            if (bundle.size() == 0) {
                System.out.println("No data for " + categoryLabel);
                continue;
            }
            chart.addSeries(categoryLabel, bundle.years(), bundle.data());
            seriesAdded = seriesAdded + 1;
        }
        if (seriesAdded != 0) {
            new SwingWrapper(chart).displayChart();
        }
    }

    /** Creates a plot of the total normalized count of WN.hyponyms(CATEGORYLABEL) from STARTYEAR to
     *  ENDYEAR using NGM as a data source, and the YRP as a yearly record processor. */
    public static void plotCategoryWeights(NGramMap ngm, WordNet wn, 
            String categoryLabel, int startYear, int endYear) {
        Set words = wn.hyponyms(categoryLabel);
        TimeSeries summedWeightHistory = ngm.summedWeightHistory(words, startYear, endYear);
        plotTS(summedWeightHistory, "Popularity", "year", "weight", categoryLabel);
    }

    /** Creates a plot of the absolute word counts for WORD from STARTYEAR to ENDYEAR, using NGM
     *  as a data source. */
    public static void plotCountHistory(NGramMap ngm, String word,
            int startYear, int endYear) {
        TimeSeries countHistory = ngm.countHistory(word, startYear, endYear);
        plotTS(countHistory, "Popularity", "year", "count", word);
    }

    /** Creates a plot of the processed history from STARTYEAR to ENDYEAR, using NGM as a data
     *  source, and the YRP as a yearly record processor. */
    public static void plotProcessedHistory(NGramMap ngm, int startYear,
            int endYear, YearlyRecordProcessor yrp) {
        plotTS(ngm.processedHistory(startYear, endYear, yrp), 
                yrp.title(), yrp.ylabel(), yrp.xlabel(), yrp.legend());
    }

    /** Creates a plot of the TimeSeries TS. */
    public static void plotTS(TimeSeries<? extends Number> ts, String title,
            String xlabel, String ylabel, String legend) {
        Collection years = ts.years();
        Collection counts = ts.data();

        Chart chart = QuickChart.getChart(title, ylabel, xlabel, legend, years, counts);
        new SwingWrapper(chart).displayChart();
    }

    /** Creates a plot of the normalized weight counts for WORD from STARTYEAR to ENDYEAR,
     *  using NGM as a data source. */
    public static void plotWeightHistory(NGramMap ngm, String word,
            int startYear, int endYear) {
        TimeSeries weightHistory = ngm.weightHistory(word, startYear, endYear);
        plotTS(weightHistory, "Popularity", "year", "weight", word);
    }

    /** Plots the normalized count of every word against the rank of every word on a 
     *  log-log plot. */
    public static void plotZipfsLaw(NGramMap ngm, int year) {
        Collection yValues = ngm.getRecord(year).counts();
        LinkedList<Integer> xValues = new LinkedList<Integer>();
        for (int i = yValues.size(); i > 0; i -= 1) {
            xValues.add(i);
        }

        String title = "Zipf's Law";
        String ylabel = "count";
        String xlabel = "rank";
        String legend = "Zipf";

        Chart chart = new ChartBuilder().width(WIDTH).height(HEIGHT)
            .xAxisTitle(ylabel).yAxisTitle(xlabel).build();
        chart.getStyleManager().setYAxisLogarithmic(true);
        chart.getStyleManager().setXAxisLogarithmic(true);
        chart.addSeries(legend, xValues, yValues);

        new SwingWrapper(chart).displayChart();
    }
}
